
resstat TODO - feel free to contact me with any feature ideas
-------------------------------------------------------------
<yushin2494@gmail.com>


for 0.2.X
	- bugs to fix 
	- sysstatアップデートに追いつく。

for 0.3.0 or later
	- シグナルハンドリング。
	- リターンコード精査。エラーチェックの簡易的な方法を作成し、各スクリプトに埋め込む。コードが不必要に長くなることは厳禁。(set -eを利用するなど)
	- エラーハンドリング関数の作成。
	  現在、checkReturnErrorFatal()を作成して、関数戻り値のチェックと標準エラー出力を実装している。まだ全体に行き渡ってはいない。
	  また、これはexit用なので、skip用の処理も作る。（単に if !実行関数;thenで良い）
	- ローカルノード/複数ノードの起動チェック機能。
	- グラフコンフィグ及びcommon.confの機能強化。set gridの様に値のないsetや、「set」の後に複数の項目が続くものはsetできない仕様（set key below right）を拡張する。
	  [SP]をスペースに変換する仕様にしたり、NONEはNOSETなのでNOVALとかいうものを作ったりすればできる。
	- HTML作成部分の出来る限り並列化。
	- ssh、scp以外のリモートコマンドに対応。（r系コマンド）
	- ssh、scpの機能強化。22番ポート以外を可能とする、ノード毎に柔軟に設定可能にする、など。
	  上のssh、scp以外のコマンド対応と合わせ、targethostの記述フォーマットを変える必要がある。
	- カラフルなmanagement_tool.shとmanagement_setup.sh
	- 各スクリプトの変数名、関数名について、独自に名前空間を分ける。
	- 複数ノードstop、configure、sync機能の並列実行化。
	- expectを使うスクリプトの安定化。（expectではなく、zptyモジュールを使えばできないか？）
	- マルチノードshow機能の高速化。(management_tool.shの応答性アップ)
	  そもそもproc_idの中身はプロセスIDのみでよかったのだが、設定時間経過の自然終了パターンの後、
	  再度実行すると旧プロセスIDの後に追記するようになっている。（そうでなければ、重複起動時に一斉stopできないし、start時に重複起動回避はstartを不要に重くする）
	  そしてstop時にプロセスをkillする際、単にproc_idファイルを読んでkillするのでは、
	  旧プロセスIDが残っているとプロセスID一周（30000と少しくらいでループ）しているプロセスが今は
	  誰がどのような形で起こしたプロセスか解らないため、ここで「誰が」「どのような」プロセスを起動したのか判定してkillする必要がある。
	  これはshowも同様であり、そのためproc_idファイルにはプロセスIDに加えて「起動ユーザ名」「起動コマンド」情報も入っている。
	  だが、これを読み込んで解析し、psコマンドの出力と照らし合わせるのは、高速性が必要な複数ノードshow機能には重すぎる。
	  ただし、元々sshで全ノードに接続する処理を、フォアグラウンドのみで逐次実行することが、ノード数によってはレスポンスに多大な影響がある。
	  (ssh接続だけでも1ノード0.2secは要する。環境にも因るが)
	  根本原因としてここを解決すべき。
	  他のmultinode系の様にバックグラウンドで流してwaitする（結果はファイルにでも書く）のも手だが、少ないノード数の時逆にオーバヘッドが大きくなる可能性もある。
	  現実案としては、show機能モードのパラメータをresstat.confに作り、切り替えを可能にすることだろう。
	  全くshowしないモード、簡易showモード（リモートアクセスしない）、フルshowモード辺りを作ればよい。
	  また、ztcpを立ててしまい、バックグラウンド実行と併用するという方法もあるが、やはり全てのノードから返答を受ける際に受け手が１プロセスなのでここが並列化出来ない点がネック。
	  ssh部分を並列化する為バックグラウンドプロセスにして、結果の取得をzsocketで取る、という方法も可能ではある。
	- 各スクリプトヘルプドキュメントとスクリプト自体の分割（必要？）。ただ、スクリプト外にするとヘルプ内の変数展開が効かせ辛いので、やり方を考えること。
	  ヘルプは関数化して外出しするのが一番良いか。
	- スクリプトヘルプをきっちり書く。今のところざっくりすぎる。
	- プロセスへのアタッチで、「ALL」を可能にする。
	- スクリプト高速化。毎回conf系のファイルを読むのではなく、一度パラメータget系の関数を起動したらコメント抜きの部分をスクリプトグローバルに確保した変数に入れておき、
	  起動のたびにconfファイル全読みを避ける。これは、コメント行等余計な部分が多くなった場合の対応。
	  多くのパラメータを読む場合には、loadAll系を作ったのでそちらで対応。
	- プロセスIDにアタッチするパターン、スレッドや子プロセスを取る(sar -X、pidstat -T CHILD、TASK、ALLなど)
	- configureを強化し、プロセスIDや割り込み番号のセットをコマンドから行い、同時にコメントインする機能（default_targetgraphとresstat.conf）。managementも同期修正。
	- mpstat -I ALL、mpstat -I SCPUの様に、カラムがマシンによって変化する場合のグラフ化。
	- pidstatなど、セパレータ項目が動的に変化する場合のグラフ化。
	- nfsiostat、cifsiostat対応。（sysstat 9.1.3～だが、未対応のまま。そもそもnfsやcifsでマウントしているファイルシステムがなければ使用不能）
	- sar -m 系の取得条件調査と、グラフ化の対応。カーネルコンフィグの調整が必要？
	- zshモジュールを活用できる部分はあるか。
	- ParamGet_*系の関数だけ命名規則が異なる。修正要。
	- 同名のツールがネット上に存在する。別のツール名を考えた方がよいかもしれない。
	- シェルに書き出している機能で、関数化して使った方が高速となる場合には関数定義だけにしておく。別プロセスを生成するのは重い。
	- また、zcompileを使用してロードを高速化すること。（libディレクトリなどに関数を全登録）
	  全ての関数はautoloadで良いが、メモリに残す様にしておく。
	  libとlib/srcディレクトリを作ってsrcに関数定義ファイルを置き、libにFPATHを通す。
	  common.shで初回時のみコンパイルと関数autoloadをするようにしておこう。（関数定義と変数定義は別ファイルのまま）
	- バックグラウンド起動をふんだんに使い、直列化しなくてよい処理のwait時間を短縮する。
	- 不要なスクリプト構成の精査。現在、resstatとctrlresstatの混在が不要で、かつ、各機能毎に別スクリプト化した方が明確である。実行速度と効率にも気を配って再構成すべき。
	- 測定項目ドキュメントの強化。各項目の意味をそれぞれ調べ直して理解し易いドキュメントとすることに加え、基本的なシステムリソースに対してはアラートを上げる機能を付ける。
	- multinodeセットアップ系で、sshのパスワード接続が封じられ、逆に公開鍵接続はあらかじめできるようなケースへの対応。

for X.X.X
	- 関数のexportがzshで不可能？bashと同じ方法では出来ない。また、マニュアルにも未記載。

